## 主线程与工作线程分工

服务器为了能够流畅的处理多个客户端连接，一般在线程 A(主线程) `accept`新的线程连接，并生成新的连接`socketfd`, 然后将这些新的`socketfd`交给另外开的数个工作线程 B1，B2， B3 等进行处理。
工作线程的框架代码为：

```cpp
while(!m_bQuit) {
  epoll_or_select_func();
  handle_io_events();
  handler_other_things();
}
```

在`epoll_or_selec_func`函数中，在没有网络 IO 和其他任务要处理时，线程挂起，避免空转。
采用以下的方式：

1. `Linux`中无论`epoll_fd`上是否存在`fd`, 我们都将其绑定到一个默认的`fd`上，称为唤醒`fd`；
2. 当我们需要处理其他任务时，向这个`fd`上写入`1`字节数据，将其变为可读。这样`select/poll/epoll`立刻返回，执行其他任务。

唤醒`fd`的实现有以下方式：

1. 管道(`pipe`), 创建一个管道，将管道绑定到`epoll_fd`上。需要时，向管道的一端写入一个字节，工作线程立刻被唤醒；
2. 利用`eventfd`函数

```cpp
int eventfd(unsigned int initval, int flags);
```

3. 利用`socketpair`

```cpp
int socketpair(int domain, int type, int protocol, int sv[2]);
```

调用这个函数返回的两个 `socket` 句柄就是` sv[0]，和 sv[1]`，在一个其中任何一个写入字节，在另外一个收取字节。
将收取的字节的 `socket` 绑定到 `epoll_fd` 上。需要时，向另外一个写入的 `socket` 上写入一个字节，工作线程立即被唤醒。如果是使用 `socketpair`，那么 `domain` 参数一定要设置成 `AFX_UNIX`.

## `Reactor`模式

主线程(`IO`处理单元)只负责监听文件描述符上是否有事件发生，有事件发生立刻通知工作线程(逻辑处理单元)。除此之外，工作线程不做任何工作。
`Reactor`工作流：

1. 主线程向`epoll`内核事件中注册`socket`上的可读事件；
2. 主线程调用`epoll_wait`等待`socket`上有数据可读；
3. 当`socket`上有数据可读时，`epoll_wait`通知主线程。主线程将`socket`可读事件放到请求队列。
4. 睡眠在请求队列的某个工作线程被唤醒，从`socket`读取数据，处理客户请求，然后向`epoll`内核注册该`socket`的写就绪事件；
5. 主线程调用`epoll_wait`等待`socket`可写；
6. 当`socket`可写时，`epoll_wait`通知主线程，主线程将`socket`可写事件放入到请求队列；
7. 睡眠在请求队列的某个工作线程被唤醒，往`socket`写入服务端处理客户请求的结果。
   ![reactor框架](./images/reactor框架.png)

示例：
